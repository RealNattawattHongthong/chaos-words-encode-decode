#!/usr/bin/env python3
import base64
from final_encode_decode import add_padding

# The two keys provided by the user
key1 = "VlVaYWIwMXJNVk1oYVJuQnJaV3R3QU5WWXlNVlpsYkVScFhZVVJLVGxZeUtVbUZVTUZKS1RWRVprZFZvemNHbFNSYldoU1ZGWmFkMU1kdFVqWlRiV3hZQVltMTBObFpyV21SOVdNREZWVkd4d0tWR0ZyY0ZOV01uRWhPWlcxT1IyRkdSYkU1V01YQmhWa01aU1MwNVdaSE5hQU0zQlNWbTFuTVZSUldhR0ZYYXpsRktVMnhhV0dKck1URVk9"
key2 = "V2tkNGJrOVZNVk1oYVJuQnFZV3R2QWVsWXlNVlpsYlZSSnpZVVZhVGxZeUtVbUZVYkZKS1RrRVprZFZvemNGWlNSYldoNlZGWmFkMU1kc2JIRlRhazVZQVltMTBObFp0ZUdSOVdWVEZWVkd4d0tWbFpGY0V4V01uRWhPWld4a1IyRklSWkU1V01YQmhXbE1aU1MxUnNaSE5hQU0zQnNWbTFvUTFSUldhR0ZYYkZwVktVMVJTV0dKck1URVk9"

def analyze_complexity(key_name, encoded):
    """Analyze the complexity of decoding by hand"""
    print(f"\n=== {key_name} Analysis ===")
    
    # Check length
    print(f"Length: {len(encoded)} characters")
    
    # Check for special characters (harder to decode by hand)
    special_chars = sum(1 for c in encoded if not c.isalnum())
    print(f"Special characters: {special_chars}")
    
    # Check Base64 structure
    print("Base64 alphabet usage:")
    uppercase = sum(1 for c in encoded if c.isupper())
    lowercase = sum(1 for c in encoded if c.islower())
    digits = sum(1 for c in encoded if c.isdigit())
    plus_slash = sum(1 for c in encoded if c in '+/')
    print(f"  Uppercase: {uppercase} ({uppercase/len(encoded)*100:.1f}%)")
    print(f"  Lowercase: {lowercase} ({lowercase/len(encoded)*100:.1f}%)")
    print(f"  Digits: {digits} ({digits/len(encoded)*100:.1f}%)")
    print(f"  +/: {plus_slash} ({plus_slash/len(encoded)*100:.1f}%)")
    
    # Try first layer of Base64 decoding
    try:
        padded = add_padding(encoded)
        layer9 = base64.b64decode(padded).decode('utf-8')
        print(f"\nInitial Base64 decode (first 30 chars): {layer9[:30]}...")
        
        # Look for patterns of MARKER insertions (layer 9)
        marker_indices = []
        for i in range(len(layer9)):
            if i > 10 and i % 11 == 10:  # Check if this is a potential marker position
                marker_indices.append(i)
                if len(marker_indices) >= 5:  # Just show a few
                    break
        
        if marker_indices:
            print(f"Potential marker positions: {marker_indices}")
            marker_chars = [layer9[i] if i < len(layer9) else 'N/A' for i in marker_indices]
            print(f"Characters at marker positions: {marker_chars}")
            
        # Calculate entropy (higher is harder to decode by hand)
        from collections import Counter
        char_counts = Counter(encoded)
        entropy = sum(-(count/len(encoded)) * (count/len(encoded)) for count in char_counts.values())
        print(f"\nCharacter distribution entropy: {entropy:.4f} (higher means more random/complex)")
        
    except Exception as e:
        print(f"Error in initial analysis: {str(e)}")
        
    print("="*50)

# Analyze both keys
analyze_complexity("Key 1 (Original Hardcoded)", key1)
analyze_complexity("Key 2 (Generated by Encoder)", key2)

# Compare layer by layer
print("\n=== LAYER-BY-LAYER COMPLEXITY COMPARISON ===")
print("Let's check if we can determine differences in the encoding layers:")

def decode_first_few_layers(encoded):
    """Try to decode the first few layers"""
    try:
        # Layer 10 - Base64 decode
        padded = add_padding(encoded)
        layer9 = base64.b64decode(padded).decode('utf-8')
        
        # Estimate layer 9 - Remove markers
        estimated_layer8 = ''
        skip_indices = set()
        for i in range(len(layer9)):
            if i > 0 and i % 11 == 10 and i < len(layer9) - 1:
                skip_indices.add(i)
                
        for i in range(len(layer9)):
            if i not in skip_indices:
                estimated_layer8 += layer9[i]
                
        # Try to decode layer 8 - First of triple Base64
        try:
            padded_layer8 = add_padding(estimated_layer8)
            first_b64_decode = base64.b64decode(padded_layer8).decode('utf-8')
            return {
                "layer9": layer9[:40] + "...",
                "estimated_layer8": estimated_layer8[:40] + "...",
                "first_b64_decode": first_b64_decode[:40] + "..."
            }
        except:
            return {
                "layer9": layer9[:40] + "...",
                "estimated_layer8": estimated_layer8[:40] + "...",
                "first_b64_decode": "Failed to decode"
            }
    except Exception as e:
        return {"error": str(e)}

# Compare first layers
print("\nKey 1 first few layers:")
key1_layers = decode_first_few_layers(key1)
for layer, value in key1_layers.items():
    print(f"{layer}: {value}")

print("\nKey 2 first few layers:")
key2_layers = decode_first_few_layers(key2)
for layer, value in key2_layers.items():
    print(f"{layer}: {value}")

# Final assessment
print("\n=== FINAL ASSESSMENT ===")
print("Based on character distribution, length, and layer complexity, the easier key to solve by hand would be determined by:")
print("1. More regular patterns in marker positions")
print("2. Less entropy in character distribution")
print("3. More recognizable patterns after initial Base64 decoding")